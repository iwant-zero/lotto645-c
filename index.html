<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>로또645 빈도 기반 추천기 (결정론 + 풀 캐시 + BGM)</title>
  <meta name="theme-color" content="#0b1220" />
  <style>
    :root{
      --bg:#0b1220; --card:#121b2e; --card2:#0f1730; --txt:#e8eefc; --muted:#9db0d3;
      --line:rgba(255,255,255,.10);
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Apple SD Gothic Neo,Noto Sans KR,sans-serif;background:var(--bg);color:var(--txt)}
    .wrap{max-width:1040px;margin:0 auto;padding:18px}
    .top{
      display:flex;gap:12px;align-items:flex-start;justify-content:space-between;flex-wrap:wrap;
      padding:14px;border:1px solid var(--line);
      background:linear-gradient(180deg,rgba(255,255,255,.05),rgba(255,255,255,.02));
      border-radius:16px;
    }
    .title{font-size:18px;font-weight:900;letter-spacing:-.2px}
    .sub{font-size:12px;color:var(--muted);margin-top:6px;line-height:1.35}
    .badge{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
    .pill{
      padding:6px 10px;border-radius:999px;border:1px solid var(--line);background:rgba(255,255,255,.03);
      font-size:12px;color:var(--muted)
    }
    .pill.ok{border-color:rgba(167,243,208,.35);background:rgba(167,243,208,.10);color:#c9ffe8}
    .pill.bad{border-color:rgba(255,120,120,.35);background:rgba(255,120,120,.10);color:#ffd0d0}
    .tabs{display:flex;gap:8px;flex-wrap:wrap}
    .tab{padding:8px 10px;border-radius:999px;border:1px solid var(--line);background:rgba(255,255,255,.03);cursor:pointer;font-weight:900;font-size:12px;color:var(--muted)}
    .tab.on{color:var(--txt);border-color:rgba(100,210,255,.35);background:rgba(100,210,255,.10)}

    .grid{margin-top:14px;display:grid;grid-template-columns:1fr;gap:12px}
    @media(min-width:900px){ .grid{grid-template-columns: 1.15fr .85fr;} }

    .card{padding:14px;border:1px solid var(--line);background:var(--card);border-radius:16px}
    .card h3{margin:0 0 10px 0;font-size:14px;color:#d6e3ff}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .input{
      flex:1 1 260px;display:flex;gap:8px;align-items:center;
      border:1px solid var(--line);background:rgba(0,0,0,.18);
      border-radius:12px;padding:10px 10px;
    }
    .input input,.input select{
      width:100%;border:0;outline:0;background:transparent;color:var(--txt);font-size:14px;
    }
    .btn{
      border:1px solid var(--line);background:rgba(255,255,255,.04);color:var(--txt);
      padding:10px 12px;border-radius:12px;font-weight:800;font-size:13px;cursor:pointer;user-select:none;
    }
    .btn:active{transform:translateY(1px)}
    .btn.primary{border-color:rgba(100,210,255,.35);background:rgba(100,210,255,.12)}
    .btn.good{border-color:rgba(167,243,208,.35);background:rgba(167,243,208,.10)}
    .btn.small{padding:8px 10px;border-radius:10px;font-size:12px}
    .hr{height:1px;background:var(--line);margin:12px 0}
    .hint{font-size:12px;color:var(--muted);line-height:1.45}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace}

    .sliderWrap{
      width:100%;border:1px solid var(--line);background:rgba(0,0,0,.16);
      border-radius:14px;padding:10px;
    }
    .sliderTop{display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap;align-items:center;margin-bottom:8px}
    input[type="range"]{width:100%}
    .mini{font-size:12px;color:var(--muted)}

    .out{display:flex;flex-direction:column;gap:10px}
    .set{
      border:1px solid var(--line);background:var(--card2);border-radius:14px;padding:12px;
      display:flex;flex-direction:column;gap:10px;
    }
    .sethead{display:flex;justify-content:space-between;align-items:center;gap:10px;flex-wrap:wrap}
    .settitle{font-weight:900;font-size:13px;color:#d6e3ff}
    .meta{font-size:12px;color:var(--muted)}
    .balls{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    .ball{
      width:38px;height:38px;border-radius:999px;display:flex;align-items:center;justify-content:center;
      font-weight:900;border:1px solid rgba(255,255,255,.20);
      box-shadow: 0 8px 16px rgba(0,0,0,.22) inset, 0 10px 22px rgba(0,0,0,.20);
    }
    .b1{background:linear-gradient(180deg,#ffd166,#f59e0b);color:#1c1400}
    .b2{background:linear-gradient(180deg,#8ec5ff,#3b82f6);color:#001225}
    .b3{background:linear-gradient(180deg,#ff8fb1,#ef4444);color:#2a0008}
    .b4{background:linear-gradient(180deg,#bff4c8,#22c55e);color:#052012}
    .b5{background:linear-gradient(180deg,#d2d2d2,#9ca3af);color:#111827}

    .footer{margin:16px 0 0;color:var(--muted);font-size:12px;line-height:1.5}
  </style>
</head>
<body>
<div class="wrap">
  <div class="top">
    <div>
      <div class="title">로또645 빈도 기반 추천기 <span class="mono" style="opacity:.7">v2.3</span></div>
      <div class="sub">
        무작위(Math.random/crypto) 없이 <b>결정론(데이터+cycle+seed+disp+preset+pool)</b>로만 추천을 순환 생성합니다.<br/>
        BGM은 <span class="mono">lotto645-c/assets/bgm/track1.mp3</span> 형태로 넣으면 자동 인식합니다.
      </div>
      <div class="badge">
        <span class="pill" id="p-health">Health: -</span>
        <span class="pill" id="p-last">Last: -</span>
        <span class="pill" id="p-updated">Updated: -</span>
        <span class="pill" id="p-cycle">Cycle: -</span>
        <span class="pill" id="p-pool">Pool: -</span>
      </div>
    </div>
    <div class="tabs" id="tabs">
      <div class="tab on" data-win="10">최근 10회</div>
      <div class="tab" data-win="20">최근 20회</div>
      <div class="tab" data-win="30">최근 30회</div>
    </div>
  </div>

  <div class="grid">
    <div class="card">
      <h3>추천 설정</h3>

      <div class="row">
        <div class="input">
          <span class="mono" style="color:var(--muted);font-weight:900">SEED</span>
          <input id="seed" placeholder="예: TEAM-A / 닉네임 / 2026-02-28-1" />
        </div>
        <div class="row">
          <div class="btn small" id="saveSeed">저장</div>
          <div class="btn small" id="shareLink">링크복사</div>
        </div>
      </div>

      <div class="hr"></div>

      <div class="row">
        <div class="input" style="flex:1 1 260px">
          <span class="mono" style="color:var(--muted);font-weight:900">PRESET</span>
          <select id="preset">
            <option value="auto">AUTO(순환)</option>
            <option value="bal">BAL(균형)</option>
            <option value="lowsum">LOW SUM</option>
            <option value="highsum">HIGH SUM</option>
            <option value="odd">ODD HEAVY</option>
            <option value="even">EVEN HEAVY</option>
            <option value="low">LOW(1~22)</option>
            <option value="high">HIGH(23~45)</option>
          </select>
        </div>
        <div class="input" style="flex:1 1 220px">
          <span class="mono" style="color:var(--muted);font-weight:900">POOL</span>
          <select id="poolSize">
            <option value="3000">3,000</option>
            <option value="5000">5,000</option>
            <option value="10000" selected>10,000</option>
          </select>
        </div>
      </div>

      <div class="hr"></div>

      <div class="sliderWrap">
        <div class="sliderTop">
          <div class="mini">
            <b style="color:#d6e3ff">밴드 분산 강도(Top 제한)</b>
            <span id="dispText" class="mono" style="margin-left:8px;opacity:.9">-</span>
          </div>
          <div class="mini" id="dispHint">-</div>
        </div>
        <input id="disp" type="range" min="0" max="100" step="1" />
        <div class="mini" style="margin-top:6px">
          낮음(0)=Top 최대 3개 · 중간(50)=Top 최대 2개 · 높음(100)=Top 최대 1개
        </div>
      </div>

      <!-- ✅ BGM 섹션(레포 assets/bgm) -->
      <div class="hr"></div>
      <h3 style="margin:0 0 10px 0">배경음악(BGM)</h3>

      <div class="row">
        <div class="input" style="flex:1 1 320px">
          <span class="mono" style="color:var(--muted);font-weight:900">TRACK</span>
          <select id="bgmSelect"></select>
        </div>
        <div class="btn small" id="bgmRefresh">리스트 새로고침</div>
      </div>

      <div class="row" style="margin-top:8px">
        <div class="btn small" id="bgmToggle">음악: OFF</div>
        <div class="btn small" id="bgmPlay">재생</div>
        <div class="btn small" id="bgmStop">정지</div>
        <div class="btn small" id="bgmClear">해제</div>
      </div>

      <div class="row" style="margin-top:8px">
        <div class="input" style="flex:1 1 220px">
          <span class="mono" style="color:var(--muted);font-weight:900">VOL</span>
          <input id="bgmVol" type="range" min="0" max="100" step="1" />
        </div>
      </div>

      <div class="hint" id="bgmStatus" style="margin-top:8px">
        assets/bgm 폴더에 track1.mp3 같은 파일을 넣고 커밋/배포하면 목록에 나타납니다.
      </div>

      <div class="hr"></div>

      <div class="row" style="justify-content:space-between">
        <div class="hint">
          <b>cycle</b>은 풀 인덱스입니다. 클릭 시 <b>count만큼</b> 증가합니다(무한 순환).<br/>
          점프 후 추천을 누르면 큰 폭으로 이동합니다.
        </div>
        <div class="row">
          <div class="btn small" id="jump50">+50</div>
          <div class="btn small" id="jump100">+100</div>
          <div class="btn small" id="jump500">+500</div>
          <div class="btn small" id="resetCycle">reset</div>
        </div>
      </div>

      <div class="hr"></div>

      <div class="row">
        <div class="btn primary" data-cnt="1">1개 추천</div>
        <div class="btn primary" data-cnt="5">5개 추천</div>
        <div class="btn primary" data-cnt="10">10개 추천</div>
        <div class="btn good" id="regen">같은 cycle 재생성(뷰 오프셋)</div>
      </div>

      <div class="footer">
        ※ BGM 자동재생은 브라우저 정책상 막힐 수 있어요(그때는 ‘재생’ 버튼 한 번).<br/>
        ※ 업데이트 상태가 DEGRADED면 최신 반영이 지연될 수 있습니다.
      </div>
    </div>

    <div class="card">
      <h3>추천 결과</h3>
      <div class="out" id="out">
        <div class="hint">데이터 로딩 중…</div>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  // ---------- Deterministic ----------
  function fnv1a32(str){
    let h = 0x811c9dc5;
    for (let i=0;i<str.length;i++){
      h ^= str.charCodeAt(i);
      h = Math.imul(h, 0x01000193) >>> 0;
    }
    return h >>> 0;
  }
  function XorShift32(seed){
    let x = (seed >>> 0) || 0x12345678;
    return {
      nextU32(){
        x ^= (x << 13) >>> 0;
        x ^= (x >>> 17) >>> 0;
        x ^= (x << 5) >>> 0;
        return x >>> 0;
      },
      nextFloat(){
        return (this.nextU32() >>> 0) / 0x100000000;
      }
    };
  }
  function clamp(n,a,b){ return Math.max(a, Math.min(b,n)); }

  function ballClass(n){
    if (n<=10) return "b1";
    if (n<=20) return "b2";
    if (n<=30) return "b3";
    if (n<=40) return "b4";
    return "b5";
  }
  function sum(arr){ return arr.reduce((p,c)=>p+c,0); }
  function oddEven(arr){
    let o=0,e=0;
    for (const n of arr) (n%2?o++:e++);
    return {o,e};
  }
  function hiLo(arr){
    let lo=0, hi=0;
    for (const n of arr) (n<=22?lo++:hi++);
    return {lo,hi};
  }

  const LS = {
    deviceSeed: "lotto645_device_seed_v2",
    userSeed: "lotto645_user_seed_v2",
    win: "lotto645_win_v3",
    cycle: (win) => `lotto645_cycle_${win}_v3`,
    viewOffset: (win) => `lotto645_viewoff_${win}_v3`,
    dispersion: "lotto645_disp_v2",
    preset: "lotto645_preset_v1",
    poolSize: "lotto645_poolsize_v1",
    pool: (key) => `lotto645_pool_${key}`,
    poolMeta: (key) => `lotto645_poolmeta_${key}`,
    seen: (key) => `lotto645_seen_${key}`,
    lastCnt: "lotto645_last_cnt_v1",

    bgmEnabled: "lotto645_bgm_enabled_v2",
    bgmVol: "lotto645_bgm_vol_v2",
    bgmTrack: "lotto645_bgm_track_v1",
  };

  function getLS(k, d=null){
    try{ const v = localStorage.getItem(k); return v==null ? d : v; }catch{ return d; }
  }
  function setLS(k, v){
    try{ localStorage.setItem(k, String(v)); }catch{}
  }

  function getDeviceSeed(){
    let s = getLS(LS.deviceSeed, "");
    if (s) return s;
    const raw = [
      navigator.userAgent || "",
      navigator.language || "",
      String(screen.width||0),
      String(screen.height||0),
      String(devicePixelRatio||1),
      (Intl.DateTimeFormat().resolvedOptions().timeZone || ""),
    ].join("|");
    s = "D-" + fnv1a32(raw).toString(16);
    setLS(LS.deviceSeed, s);
    return s;
  }

  async function fetchFirstOk(urls){
    let lastErr = null;
    for (const u of urls){
      try{
        const res = await fetch(u, { cache: "no-store" });
        if (!res.ok) throw new Error("HTTP " + res.status);
        return await res.json();
      }catch(e){ lastErr = e; }
    }
    throw lastErr || new Error("fetch failed");
  }

  let DATA = null;
  let WIN = Number(getLS(LS.win, "10")) || 10;
  WIN = [10,20,30].includes(WIN) ? WIN : 10;

  function getCycle(){ return Number(getLS(LS.cycle(WIN), "0")) || 0; }
  function setCycle(v){ setLS(LS.cycle(WIN), String(Math.max(0, Math.floor(v)))); updateHeader(); }
  function getViewOffset(){ return Number(getLS(LS.viewOffset(WIN), "0")) || 0; }
  function setViewOffset(v){ setLS(LS.viewOffset(WIN), String(Math.max(0, Math.floor(v)))); }

  function getDisp(){ return clamp(Number(getLS(LS.dispersion, "50")) || 50, 0, 100); }
  function setDisp(v){ setLS(LS.dispersion, String(clamp(Math.floor(v),0,100))); updateHeader(); }

  function getPreset(){ return getLS(LS.preset, "auto") || "auto"; }
  function setPreset(v){ setLS(LS.preset, v); updateHeader(); }

  function getPoolSize(){ return Number(getLS(LS.poolSize, "10000")) || 10000; }
  function setPoolSize(v){ setLS(LS.poolSize, String(v)); updateHeader(); }

  function getLastCnt(){
    const v = Number(getLS(LS.lastCnt, "5"));
    return [1,5,10].includes(v) ? v : 5;
  }
  function setLastCnt(v){
    if ([1,5,10].includes(v)) setLS(LS.lastCnt, String(v));
  }

  function setTab(win){
    WIN = win;
    setLS(LS.win, String(win));
    document.querySelectorAll(".tab").forEach(t=> t.classList.toggle("on", Number(t.dataset.win)===WIN));
    updateHeader();
    preview();
  }

  function normalizeRanksFromCounts(counts){
    const arr = [];
    for (let i=1;i<=45;i++){
      arr.push({n:i, c:Number(counts[i]||0)});
    }
    arr.sort((a,b)=> b.c - a.c || a.n - b.n);
    const rank = {};
    arr.forEach((o, idx)=> rank[o.n] = idx+1);
    return rank;
  }

  function getWeights(win){
    if (win===10) return {rw:0.60, ow:0.40};
    if (win===20) return {rw:0.45, ow:0.55};
    return {rw:0.35, ow:0.65};
  }

  function buildScoredNumbers(win){
    const overallRank = normalizeRanksFromCounts(DATA.overall.main);
    const recentCounts = (DATA.recentWeighted && DATA.recentWeighted[String(win)] && DATA.recentWeighted[String(win)].main)
      ? DATA.recentWeighted[String(win)].main
      : DATA.recent[String(win)].main;

    const recentRank = normalizeRanksFromCounts(recentCounts);
    const {rw, ow} = getWeights(win);

    const scored = [];
    for (let n=1;n<=45;n++){
      const s = (46-overallRank[n]) * ow + (46-recentRank[n]) * rw;
      scored.push({n, s});
    }
    scored.sort((a,b)=> b.s - a.s || a.n - b.n);
    return scored;
  }

  function buildScorePos(scored){
    const pos = {};
    scored.forEach((o, i)=> pos[o.n] = i+1);
    return pos;
  }

  function topLimitFromDisp(d){
    if (d >= 67) return 1;
    if (d >= 34) return 2;
    return 3;
  }

  function applyTopLimit(pat, topLimit){
    let t = pat[0], m = pat[1], l = pat[2];
    const cut = Math.max(0, t - topLimit);
    if (cut === 0) return [t,m,l];
    t -= cut;
    m += cut;
    if (m > 4){
      const over = m - 4;
      m -= over;
      l += over;
    }
    return [t,m,l];
  }

  const PATTERNS = [
    [2,2,2],
    [3,2,1],
    [2,3,1],
    [1,3,2],
    [3,1,2],
    [2,1,3],
  ];

  const PRESETS = {
    auto: { id:"auto", name:"AUTO" },
    bal: { id:"bal", name:"BAL", sum:[95,185], odd:[2,4], low:[2,4] },
    lowsum: { id:"lowsum", name:"LOW SUM", sum:[80,150] },
    highsum: { id:"highsum", name:"HIGH SUM", sum:[130,205] },
    odd: { id:"odd", name:"ODD", odd:[4,6] },
    even: { id:"even", name:"EVEN", odd:[0,2] },
    low: { id:"low", name:"LOW", low:[4,6] },
    high: { id:"high", name:"HIGH", low:[0,2] },
  };

  const AUTO_ROTATE = ["bal","lowsum","highsum","odd","even","low","high"];

  function presetForSet(presetId, cycle, setIndex){
    if (presetId !== "auto") return PRESETS[presetId] || PRESETS.bal;
    const pick = AUTO_ROTATE[(cycle + setIndex) % AUTO_ROTATE.length];
    return PRESETS[pick] || PRESETS.bal;
  }

  function passPreset(arr, preset){
    const s = sum(arr);
    const oe = oddEven(arr);
    const hl = hiLo(arr);

    if (s < 80 || s > 210) return false;
    if (oe.o === 0 || oe.e === 0) return false;

    if (preset.sum){
      if (s < preset.sum[0] || s > preset.sum[1]) return false;
    }
    if (preset.odd){
      if (oe.o < preset.odd[0] || oe.o > preset.odd[1]) return false;
    }
    if (preset.low){
      if (hl.lo < preset.low[0] || hl.lo > preset.low[1]) return false;
    }
    return true;
  }

  function pickWeighted(list, rng, used, weightPow=1.0){
    let total = 0;
    for (const o of list){
      if (used.has(o.n)) continue;
      const w = Math.pow(o.s + 0.01, weightPow);
      total += w;
    }
    if (total <= 0) return null;
    let t = rng.nextFloat() * total;
    for (const o of list){
      if (used.has(o.n)) continue;
      const w = Math.pow(o.s + 0.01, weightPow);
      t -= w;
      if (t <= 0) return o.n;
    }
    for (const o of list) if (!used.has(o.n)) return o.n;
    return null;
  }

  function makeOneSet(scored, win, baseCycle, setIndex, seedStr, dispersion, presetId){
    const top = scored.slice(0,15);
    const mid = scored.slice(15,30);
    const low = scored.slice(30,45);

    const pat0 = PATTERNS[(baseCycle + setIndex) % PATTERNS.length];
    const topLimit = topLimitFromDisp(dispersion);
    const pat = applyTopLimit(pat0, topLimit);

    const weightPow = 1.00 - (dispersion/100) * 0.22;
    const preset = presetForSet(presetId, baseCycle, setIndex);

    const base = `${seedStr}|last:${DATA.lastDraw.drwNo}|win:${win}|cycle:${baseCycle}|i:${setIndex}|disp:${dispersion}|preset:${preset.id}`;
    const rng = XorShift32(fnv1a32(base));

    const used = new Set();
    const out = [];

    for (let k=0;k<pat[0];k++){
      const n = pickWeighted(top, rng, used, weightPow); if (n==null) break;
      used.add(n); out.push(n);
    }
    for (let k=0;k<pat[1];k++){
      const n = pickWeighted(mid, rng, used, weightPow); if (n==null) break;
      used.add(n); out.push(n);
    }
    for (let k=0;k<pat[2];k++){
      const n = pickWeighted(low, rng, used, weightPow); if (n==null) break;
      used.add(n); out.push(n);
    }

    out.sort((a,b)=>a-b);
    if (!passPreset(out, preset)) return null;
    return { arr: out, presetUsed: preset.id };
  }

  function bandCounts(arr, scorePos){
    let T=0,M=0,L=0;
    for (const n of arr){
      const p = scorePos[n] || 999;
      if (p <= 15) T++;
      else if (p <= 30) M++;
      else L++;
    }
    return {T,M,L};
  }

  function poolKey(){
    const seed = (document.querySelector("#seed").value || "").trim();
    const disp = getDisp();
    const preset = getPreset();
    const ps = getPoolSize();
    const dev = getDeviceSeed();
    const raw = `v:${DATA.schemaVersion||0}|last:${DATA.lastDraw.drwNo}|win:${WIN}|disp:${disp}|preset:${preset}|pool:${ps}|seed:${seed}|dev:${dev}`;
    return fnv1a32(raw).toString(16);
  }

  function getSeedString(){
    const d = getDeviceSeed();
    const u = (document.querySelector("#seed").value || "").trim();
    return u ? `${d}|U:${u}` : `${d}|U:(empty)`;
  }

  function loadPool(key){
    try{
      const metaRaw = getLS(LS.poolMeta(key), null);
      const dataRaw = getLS(LS.pool(key), null);
      if (!metaRaw || !dataRaw) return null;
      const meta = JSON.parse(metaRaw);
      if (!meta || meta.key !== key) return null;
      return { meta, dataRaw };
    }catch{ return null; }
  }

  function savePool(key, meta, lines){
    setLS(LS.poolMeta(key), JSON.stringify(meta));
    setLS(LS.pool(key), lines.join("\n"));
  }

  function getSeen(key){
    try{
      const raw = getLS(LS.seen(key), "[]");
      const arr = JSON.parse(raw);
      return Array.isArray(arr) ? arr : [];
    }catch{ return []; }
  }
  function seenHas(key, fp){
    const arr = getSeen(key);
    return arr.includes(fp);
  }
  function pushSeen(key, fp){
    const arr = getSeen(key);
    arr.push(fp);
    const trimmed = arr.slice(-5000);
    setLS(LS.seen(key), JSON.stringify(trimmed));
  }

  function parsePoolLines(dataRaw){
    const lines = dataRaw.split("\n").filter(Boolean);
    const sets = [];
    for (const ln of lines){
      const parts = ln.split("|");
      const nums = parts[0].split(",").map(x=>Number(x.trim())).filter(n=>Number.isFinite(n));
      const presetUsed = parts[1] || "bal";
      if (nums.length === 6) sets.push({arr: nums, presetUsed});
    }
    return sets;
  }

  function buildPoolNow(){
    const outEl = document.querySelector("#out");
    outEl.innerHTML = `<div class="hint">조합 풀 생성 중… (처음 1회만)</div>`;

    const key = poolKey();
    const scored = buildScoredNumbers(WIN);
    const ps = getPoolSize();
    const disp = getDisp();
    const presetId = getPreset();
    const seedStr = getSeedString();

    const lines = [];
    const seenLocal = new Set();
    const maxTry = ps * 25;

    let tries = 0;
    let idx = 0;

    while (lines.length < ps && tries < maxTry){
      tries++;
      const r = makeOneSet(scored, WIN, idx, 0, seedStr, disp, presetId);
      idx++;

      if (!r) continue;

      const fp = r.arr.join("-");
      if (seenLocal.has(fp)) continue;

      seenLocal.add(fp);
      lines.push(`${r.arr.join(",")}|${r.presetUsed}`);
    }

    const meta = {
      key,
      createdAt: new Date().toISOString(),
      schemaVersion: DATA.schemaVersion || 0,
      lastDraw: DATA.lastDraw.drwNo,
      win: WIN,
      dispersion: disp,
      preset: presetId,
      poolSize: ps,
      generated: lines.length,
      tries,
      note: lines.length < ps ? "pool_partial_generated" : "pool_full_generated",
    };

    savePool(key, meta, lines);
    return { key, meta, sets: parsePoolLines(lines.join("\n")) };
  }

  function ensurePool(){
    const key = poolKey();
    const loaded = loadPool(key);
    if (loaded){
      const sets = parsePoolLines(loaded.dataRaw);
      return { key, meta: loaded.meta, sets };
    }
    return buildPoolNow();
  }

  function renderSets(items, scorePos){
    const out = document.querySelector("#out");
    out.innerHTML = "";

    items.forEach((it, idx)=>{
      const arr = it.arr;
      const presetUsed = it.presetUsed || "bal";
      const s = sum(arr);
      const oe = oddEven(arr);
      const hl = hiLo(arr);
      const bc = bandCounts(arr, scorePos);

      const el = document.createElement("div");
      el.className = "set";

      const head = document.createElement("div");
      head.className = "sethead";

      const title = document.createElement("div");
      title.className = "settitle";
      title.textContent = `#${String(idx+1).padStart(2,"0")} 추천`;

      const meta = document.createElement("div");
      meta.className = "meta";
      meta.textContent =
        `합 ${s} · 홀/짝 ${oe.o}/${oe.e} · 저/고 ${hl.lo}/${hl.hi} · 밴드 T/M/L ${bc.T}/${bc.M}/${bc.L} · preset ${presetUsed}`;

      const btnRow = document.createElement("div");
      btnRow.className = "row";

      const copyNums = document.createElement("div");
      copyNums.className = "btn small";
      copyNums.textContent = "숫자복사";
      copyNums.onclick = async () => {
        const txt = arr.join(", ");
        try{
          await navigator.clipboard.writeText(txt);
          copyNums.textContent = "복사됨";
          setTimeout(()=>copyNums.textContent="숫자복사", 900);
        }catch{
          alert("복사 실패:\n" + txt);
        }
      };

      const copyOne = document.createElement("div");
      copyOne.className = "btn small";
      copyOne.textContent = "한줄복사";
      copyOne.onclick = async () => {
        const txt = `${arr.join(", ")} | T/M/L ${bc.T}/${bc.M}/${bc.L} | 합 ${s} | 홀/짝 ${oe.o}/${oe.e} | 저/고 ${hl.lo}/${hl.hi} | preset ${presetUsed}`;
        try{
          await navigator.clipboard.writeText(txt);
          copyOne.textContent = "복사됨";
          setTimeout(()=>copyOne.textContent="한줄복사", 900);
        }catch{
          alert("복사 실패:\n" + txt);
        }
      };

      btnRow.appendChild(copyNums);
      btnRow.appendChild(copyOne);

      head.appendChild(title);
      head.appendChild(meta);
      head.appendChild(btnRow);

      const balls = document.createElement("div");
      balls.className = "balls";
      arr.forEach(n=>{
        const b = document.createElement("div");
        b.className = "ball " + ballClass(n);
        b.textContent = String(n);
        balls.appendChild(b);
      });

      el.appendChild(head);
      el.appendChild(balls);
      out.appendChild(el);
    });
  }

  function updateDispUI(){
    const disp = getDisp();
    const topMax = topLimitFromDisp(disp);
    document.querySelector("#dispText").textContent = `disp=${disp} / topMax=${topMax}`;
    document.querySelector("#dispHint").textContent = `상위 쏠림 완화 + top 최대 ${topMax}개`;
    const slider = document.querySelector("#disp");
    if (Number(slider.value) !== disp) slider.value = String(disp);
  }

  function updateHeader(poolMeta=null){
    const h = document.querySelector("#p-health");
    const pLast = document.querySelector("#p-last");
    const pUpd = document.querySelector("#p-updated");
    const pCyc = document.querySelector("#p-cycle");
    const pPool = document.querySelector("#p-pool");

    if (DATA){
      const ok = (DATA.health && DATA.health.status === "ok");
      h.textContent = `Health: ${ok ? "OK" : "DEGRADED"}`;
      h.classList.toggle("ok", !!ok);
      h.classList.toggle("bad", !ok);

      pLast.textContent = `Last: ${DATA.lastDraw.drwNo} (${DATA.lastDraw.date})`;
      pUpd.textContent = `Updated: ${new Date(DATA.updatedAt).toLocaleString()}`;
    } else {
      h.textContent = "Health: -";
      pLast.textContent = "Last: -";
      pUpd.textContent = "Updated: -";
    }

    pCyc.textContent = `Cycle: ${getCycle()} / Win: ${WIN}회`;

    if (poolMeta){
      pPool.textContent = `Pool: ${poolMeta.generated || 0}/${poolMeta.poolSize || 0}`;
    } else {
      pPool.textContent = `Pool: -`;
    }

    updateDispUI();
  }

  function recommend(count){
    if (!DATA) return;

    setLastCnt(count);

    const scored = buildScoredNumbers(WIN);
    const scorePos = buildScorePos(scored);

    const key = poolKey();
    const pool = ensurePool();
    const sets = pool.sets;
    const size = sets.length;

    if (!size){
      document.querySelector("#out").innerHTML = `<div class="hint">풀 생성 실패(조건이 너무 빡빡할 수 있음). preset/disp를 조정하세요.</div>`;
      return;
    }

    const baseIndex = getCycle();
    const viewOff = getViewOffset();

    const picked = [];
    let idx = (baseIndex + viewOff * count) % size;

    for (let i=0; i<count; i++){
      let guard = 0;
      while (guard < size){
        const item = sets[idx];
        const fp = `${item.arr.join("-")}|w${WIN}|d${getDisp()}|p${getPreset()}|ps${getPoolSize()}`;
        idx = (idx + 1) % size;
        guard++;

        if (seenHas(key, fp)) continue;
        pushSeen(key, fp);
        picked.push(item);
        break;
      }
    }

    setCycle(baseIndex + count);
    renderSets(picked, scorePos);
    updateHeader(pool.meta);
  }

  function preview(){
    if (!DATA) return;

    const scored = buildScoredNumbers(WIN);
    const scorePos = buildScorePos(scored);
    const pool = ensurePool();
    const sets = pool.sets;
    const size = sets.length;

    if (!size){
      document.querySelector("#out").innerHTML = `<div class="hint">풀 생성 실패. preset/disp/poolSize를 조정해 보세요.</div>`;
      updateHeader(pool.meta);
      return;
    }

    const cnt = getLastCnt();
    const baseIndex = getCycle();
    const viewOff = getViewOffset();
    let idx = (baseIndex + viewOff * cnt) % size;

    const picked = [];
    for (let i=0;i<cnt;i++){
      picked.push(sets[idx]);
      idx = (idx+1) % size;
    }

    renderSets(picked, scorePos);
    updateHeader(pool.meta);
  }

  function applyQueryParams(){
    const q = new URLSearchParams(location.search);
    const qWin = Number(q.get("win"));
    const qCycle = Number(q.get("cycle"));
    const qSeed = (q.get("seed") || "").trim();
    const qDisp = Number(q.get("disp"));
    const qPreset = (q.get("preset") || "").trim();
    const qPool = Number(q.get("pool"));
    const qCnt = Number(q.get("cnt"));

    if ([10,20,30].includes(qWin)) WIN = qWin;
    setLS(LS.win, String(WIN));

    if (Number.isFinite(qCycle) && qCycle >= 0) setLS(LS.cycle(WIN), String(Math.floor(qCycle)));
    if (Number.isFinite(qDisp)) setDisp(qDisp);
    if (Number.isFinite(qPool) && [3000,5000,10000].includes(qPool)) setPoolSize(qPool);

    const seedEl = document.querySelector("#seed");
    const savedSeed = getLS(LS.userSeed, "");
    seedEl.value = qSeed || savedSeed || "";

    if (qPreset && PRESETS[qPreset]) setPreset(qPreset);
    if ([1,5,10].includes(qCnt)) setLastCnt(qCnt);

    document.querySelectorAll(".tab").forEach(t=> t.classList.toggle("on", Number(t.dataset.win)===WIN));
    document.querySelector("#disp").value = String(getDisp());
    document.querySelector("#preset").value = getPreset();
    document.querySelector("#poolSize").value = String(getPoolSize());

    return { cnt: ([1,5,10].includes(qCnt) ? qCnt : null) };
  }

  async function copyShareLink(cnt=null){
    const seed = (document.querySelector("#seed").value || "").trim();
    const url = new URL(location.href);
    url.searchParams.set("win", String(WIN));
    url.searchParams.set("cycle", String(getCycle()));
    url.searchParams.set("disp", String(getDisp()));
    url.searchParams.set("preset", String(getPreset()));
    url.searchParams.set("pool", String(getPoolSize()));
    url.searchParams.set("cnt", String(cnt || getLastCnt()));
    if (seed) url.searchParams.set("seed", seed);
    else url.searchParams.delete("seed");

    try{
      await navigator.clipboard.writeText(url.toString());
      alert("링크를 복사했어요:\n" + url.toString());
    }catch{
      prompt("복사해서 공유하세요:", url.toString());
    }
  }

  // =====================
  // BGM: repo assets/bgm autodiscovery
  // =====================
  const BGM_DIR = "./assets/bgm/";
  const BGM_EXTS = ["mp3","mp4","m4a","ogg","wav"];
  const BGM_MAX = 50; // track1..track50
  const bgmSelect = document.querySelector("#bgmSelect");
  const bgmRefresh = document.querySelector("#bgmRefresh");
  const bgmToggle = document.querySelector("#bgmToggle");
  const bgmPlay = document.querySelector("#bgmPlay");
  const bgmStop = document.querySelector("#bgmStop");
  const bgmClear = document.querySelector("#bgmClear");
  const bgmVol = document.querySelector("#bgmVol");
  const bgmStatus = document.querySelector("#bgmStatus");

  const bgmAudio = document.createElement("audio");
  bgmAudio.preload = "auto";
  bgmAudio.loop = true;

  const bgmVideo = document.createElement("video");
  bgmVideo.preload = "auto";
  bgmVideo.loop = true;
  bgmVideo.playsInline = true;
  bgmVideo.style.display = "none";
  document.body.appendChild(bgmVideo);

  let bgmEnabled = (getLS(LS.bgmEnabled, "0") === "1");
  let using = "audio"; // audio|video
  let currentUrl = ""; // selected track url

  function setBgmStatus(msg){ if (bgmStatus) bgmStatus.textContent = msg; }
  function isBgmPlaying(){
    const el = (using === "video") ? bgmVideo : bgmAudio;
    return !el.paused && !el.ended;
  }
  function setBgmUi(){
    if (bgmToggle) bgmToggle.textContent = `음악: ${bgmEnabled ? "ON" : "OFF"}`;
    if (bgmPlay) bgmPlay.textContent = isBgmPlaying() ? "일시정지" : "재생";
  }

  function stopBgm(){
    bgmAudio.pause(); bgmVideo.pause();
    try{ bgmAudio.currentTime = 0; }catch{}
    try{ bgmVideo.currentTime = 0; }catch{}
    setBgmUi();
  }
  function clearBgm(){
    stopBgm();
    bgmAudio.removeAttribute("src");
    bgmVideo.removeAttribute("src");
    bgmAudio.load(); bgmVideo.load();
    currentUrl = "";
    setLS(LS.bgmTrack, "");
    setBgmStatus("BGM 해제됨");
    setBgmUi();
  }

  function guessMimeByExt(ext){
    const e = (ext||"").toLowerCase();
    if (e === "mp3") return "audio/mpeg";
    if (e === "m4a") return "audio/mp4";
    if (e === "ogg") return "audio/ogg";
    if (e === "wav") return "audio/wav";
    if (e === "mp4") return "video/mp4";
    return "";
  }

  function pickPlayerForMime(mime){
    const a = bgmAudio.canPlayType(mime || "");
    if (a) return "audio";
    const v = bgmVideo.canPlayType(mime || "");
    if (v) return "video";
    // mp4는 보통 video가 더 안정적
    if ((mime||"").includes("video/mp4")) return "video";
    return "audio";
  }

  function applyVolumeFromLS(){
    const v = Number(getLS(LS.bgmVol, "60"));
    const vv = Number.isFinite(v) ? clamp(v,0,100) : 60;
    if (bgmVol) bgmVol.value = String(vv);
    const vol01 = vv / 100;
    bgmAudio.volume = vol01;
    bgmVideo.volume = vol01;
  }

  async function tryPlayBgm(){
    if (!bgmEnabled){
      setBgmStatus("음악 OFF");
      setBgmUi();
      return;
    }
    const el = (using === "video") ? bgmVideo : bgmAudio;
    if (!el.src){
      setBgmStatus("트랙을 선택하세요.");
      setBgmUi();
      return;
    }
    try{
      const p = el.play();
      if (p && typeof p.then === "function") await p;
      setBgmStatus("재생 중");
    }catch{
      setBgmStatus("자동재생이 차단됐어요. '재생' 버튼을 한 번 더 눌러주세요.");
    }finally{
      setBgmUi();
    }
  }

  function setTrackUrl(url){
    currentUrl = url || "";
    setLS(LS.bgmTrack, currentUrl);

    stopBgm();
    bgmAudio.removeAttribute("src");
    bgmVideo.removeAttribute("src");
    bgmAudio.load();
    bgmVideo.load();

    if (!currentUrl){
      setBgmStatus("트랙 해제됨");
      setBgmUi();
      return;
    }

    const ext = (currentUrl.split(".").pop() || "").toLowerCase();
    const mime = guessMimeByExt(ext);
    using = pickPlayerForMime(mime);

    if (using === "video"){
      bgmVideo.src = currentUrl;
      bgmVideo.load();
    } else {
      bgmAudio.src = currentUrl;
      bgmAudio.load();
    }

    setBgmStatus(`선택됨: ${currentUrl.replace(BGM_DIR,"")}`);
    setBgmUi();

    // ON이면 재생 시도(막히면 안내)
    if (bgmEnabled) tryPlayBgm();
  }

  // 파일 존재 확인: HEAD가 안 되면 GET 후 body cancel
  async function urlExists(url){
    try{
      const res = await fetch(url, { method: "HEAD", cache: "no-store" });
      if (res.ok) return true;
    }catch{}
    try{
      const res = await fetch(url, { method: "GET", cache: "no-store" });
      if (!res.ok) return false;
      try{ res.body && res.body.cancel && res.body.cancel(); }catch{}
      return true;
    }catch{
      return false;
    }
  }

  async function scanTracks(){
    setBgmStatus("트랙 검색 중… (track1~track50)");
    const found = [];
    for (let i=1;i<=BGM_MAX;i++){
      for (const ext of BGM_EXTS){
        const name = `track${i}.${ext}`;
        const url = `${BGM_DIR}${name}`;
        // 존재하면 추가
        // eslint-disable-next-line no-await-in-loop
        const ok = await urlExists(url);
        if (ok) found.push({ name, url });
      }
    }
    return found;
  }

  function fillSelect(list){
    bgmSelect.innerHTML = "";
    const opt0 = document.createElement("option");
    opt0.value = "";
    opt0.textContent = list.length ? "트랙 선택…" : "트랙 없음 (assets/bgm에 파일 넣기)";
    bgmSelect.appendChild(opt0);

    for (const t of list){
      const o = document.createElement("option");
      o.value = t.url;
      o.textContent = t.name;
      bgmSelect.appendChild(o);
    }

    // restore selection
    const saved = getLS(LS.bgmTrack, "");
    if (saved){
      const has = list.some(x => x.url === saved);
      bgmSelect.value = has ? saved : "";
      if (has) setTrackUrl(saved);
      else setBgmStatus("저장된 트랙이 없어졌어요. 다시 선택하세요.");
    } else {
      setBgmStatus(list.length ? "트랙을 선택하세요." : "assets/bgm에 track1.mp3 같은 파일을 넣고 배포하세요.");
    }
    setBgmUi();
  }

  async function refreshTracks(){
    try{
      const list = await scanTracks();
      fillSelect(list);
      if (!list.length) setBgmStatus("트랙이 없습니다. assets/bgm에 track1.mp3 넣고 커밋/배포하세요.");
      else setBgmStatus(`트랙 ${list.length}개 발견`);
    }catch(e){
      setBgmStatus("트랙 검색 실패(배포/경로 확인 필요)");
      console.error(e);
    }
  }

  // BGM 이벤트
  bgmSelect.addEventListener("change", () => setTrackUrl(bgmSelect.value));
  bgmRefresh.addEventListener("click", refreshTracks);

  bgmToggle.addEventListener("click", () => {
    bgmEnabled = !bgmEnabled;
    setLS(LS.bgmEnabled, bgmEnabled ? "1" : "0");
    if (!bgmEnabled) stopBgm();
    setBgmUi();
    setBgmStatus(bgmEnabled ? "음악 ON" : "음악 OFF");
    if (bgmEnabled) tryPlayBgm();
  });

  bgmPlay.addEventListener("click", async () => {
    if (!bgmEnabled){
      setBgmStatus("먼저 음악 ON으로 켜세요.");
      return;
    }
    const el = (using === "video") ? bgmVideo : bgmAudio;
    if (!el.src){
      setBgmStatus("트랙을 선택하세요.");
      return;
    }
    if (isBgmPlaying()){
      el.pause();
      setBgmStatus("일시정지");
      setBgmUi();
    } else {
      await tryPlayBgm();
    }
  });

  bgmStop.addEventListener("click", () => {
    stopBgm();
    setBgmStatus("정지");
  });

  bgmClear.addEventListener("click", clearBgm);

  bgmVol.addEventListener("input", () => {
    const vv = Number(bgmVol.value);
    setLS(LS.bgmVol, String(vv));
    const vol01 = clamp(vv,0,100)/100;
    bgmAudio.volume = vol01;
    bgmVideo.volume = vol01;
    setBgmUi();
  });

  // ---------- UI events ----------
  document.querySelectorAll(".tab").forEach(t=>{
    t.addEventListener("click", ()=> setTab(Number(t.dataset.win)));
  });

  document.querySelectorAll(".btn.primary").forEach(b=>{
    b.addEventListener("click", ()=> recommend(Number(b.dataset.cnt)));
  });

  // A 방식: 뷰 오프셋 버튼은 마지막 추천 개수로 재생성
  document.querySelector("#regen").addEventListener("click", ()=>{
    setViewOffset(getViewOffset() + 1);
    recommend(getLastCnt());
  });

  document.querySelector("#saveSeed").addEventListener("click", ()=>{
    const v = (document.querySelector("#seed").value || "").trim();
    setLS(LS.userSeed, v);
    setViewOffset(0);
    preview();
  });

  document.querySelector("#shareLink").addEventListener("click", ()=> copyShareLink(null));

  document.querySelector("#jump50").addEventListener("click", ()=> { setCycle(getCycle()+50); preview(); });
  document.querySelector("#jump100").addEventListener("click", ()=> { setCycle(getCycle()+100); preview(); });
  document.querySelector("#jump500").addEventListener("click", ()=> { setCycle(getCycle()+500); preview(); });
  document.querySelector("#resetCycle").addEventListener("click", ()=> { setCycle(0); setViewOffset(0); preview(); });

  document.querySelector("#disp").addEventListener("input", (e)=>{
    setDisp(Number(e.target.value));
    setViewOffset(0);
    preview();
  });

  document.querySelector("#preset").addEventListener("change", (e)=>{
    setPreset(e.target.value);
    setViewOffset(0);
    preview();
  });

  document.querySelector("#poolSize").addEventListener("change", (e)=>{
    setPoolSize(Number(e.target.value));
    setViewOffset(0);
    preview();
  });

  async function init(){
    const afterQP = applyQueryParams();

    DATA = await fetchFirstOk([
      "./data/lotto645_freq.json",
      "../data/lotto645_freq.json",
      "../../data/lotto645_freq.json",
    ]);

    document.querySelector("#disp").value = String(getDisp());
    document.querySelector("#preset").value = getPreset();
    document.querySelector("#poolSize").value = String(getPoolSize());

    applyVolumeFromLS();
    setBgmUi();
    setBgmStatus("트랙 목록 준비 중…");
    refreshTracks();

    preview();

    if (afterQP.cnt){
      recommend(afterQP.cnt);
    }
  }

  init().catch(err=>{
    console.error(err);
    document.querySelector("#out").innerHTML =
      `<div class="hint">데이터 로딩 실패: ${String(err && err.message || err)}<br/>Actions 업데이트가 아직 안 되었을 수 있어요.</div>`;
    updateHeader(null);
  });
})();
</script>
</body>
</html>
